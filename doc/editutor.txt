*editutor.txt*  ai-editutor - Learn while you build

==============================================================================
CONTENTS                                                    *editutor-contents*

    1. Introduction .......................... |editutor-introduction|
    2. Requirements .......................... |editutor-requirements|
    3. Installation .......................... |editutor-installation|
    4. Configuration ......................... |editutor-configuration|
    5. Usage ................................. |editutor-usage|
    6. Question Blocks ....................... |editutor-question-blocks|
    7. Visual Selection ...................... |editutor-visual|
    8. Batch Processing ...................... |editutor-batch|
    9. Context Extraction .................... |editutor-context|
   10. Knowledge Tracking .................... |editutor-knowledge|
   11. Commands .............................. |editutor-commands|
   12. Keymaps ............................... |editutor-keymaps|
   13. API ................................... |editutor-api|

==============================================================================
1. INTRODUCTION                                         *editutor-introduction*

Build projects. Ask questions. Level up.

ai-editutor is a Neovim plugin for developers who learn by building.

You're building something real. You have questions. Instead of breaking
your flow to search Stack Overflow or switch to ChatGPT, you ask right
here in your code.

v3.0 - Question Blocks:
  Explicit question blocks with `[Q:id]` and `[PENDING:id]` markers.
  Unique timestamp-based IDs. Batch processing. Reliable parsing.

Workflow: >
    1. Press <leader>mq to spawn a question block
    2. Type your question
    3. Press <leader>ma to get answer(s)
<

==============================================================================
2. REQUIREMENTS                                         *editutor-requirements*

Required:
  - Neovim 0.9.0+
  - plenary.nvim (for HTTP requests)
  - An API key for Claude/OpenAI (or local Ollama)

Recommended:
  - nvim-treesitter (for better code parsing)
  - LSP server for your language (for enhanced context)

==============================================================================
3. INSTALLATION                                         *editutor-installation*

Using lazy.nvim: >lua
    {
      "iknizzz1807/ai-editutor",
      dependencies = {
        "nvim-lua/plenary.nvim",
        "nvim-treesitter/nvim-treesitter",  -- Recommended
      },
      config = function()
        require("editutor").setup({
          provider = "claude",
        })
      end,
    }
<

==============================================================================
4. CONFIGURATION                                       *editutor-configuration*

Default configuration: >lua
    require("editutor").setup({
      -- LLM Provider
      provider = "claude",  -- claude, openai, deepseek, gemini, groq, ollama
      model = "claude-sonnet-4-20250514",

      -- Behavior
      language = "English",  -- or "Vietnamese"

      -- Context extraction
      context = {
        token_budget = 20000,  -- Max tokens for context
      },

      -- Keymaps
      keymaps = {
        question = "<leader>mq",  -- Spawn a new question block
        ask = "<leader>ma",       -- Process all pending questions
      },
    })
<

==============================================================================
5. USAGE                                                       *editutor-usage*

Basic Usage:

1. Press <leader>mq to spawn a question block: >
    /* [Q:q_1737200000000]

    [PENDING:q_1737200000000]
    */
<

2. Type your question (cursor is placed in input area): >
    /* [Q:q_1737200000000]
    What is closure and when should I use it?
    [PENDING:q_1737200000000]
    */
<

3. Press <leader>ma to process all pending questions

4. Answer replaces [PENDING:id]: >
    /* [Q:q_1737200000000]
    What is closure and when should I use it?

    A closure is a function that captures variables from its surrounding scope.
    When the inner function is returned, it maintains access to those variables
    even after the outer function has finished executing.

    Use closures for:
    - Data privacy (private variables)
    - Factory functions
    - Callbacks and event handlers
    */
<

==============================================================================
6. QUESTION BLOCKS                                   *editutor-question-blocks*

Question blocks use explicit markers with unique IDs:

Format: >
    /* [Q:q_<timestamp>]
    Your question here
    [PENDING:q_<timestamp>]
    */
<

The `[Q:id]` marker identifies the question.
The `[PENDING:id]` marker indicates the question needs an answer.

After processing, `[PENDING:id]` is replaced with the AI response.

ID Format:
  - `q_<timestamp_ms>` (e.g., `q_1737200000000`)
  - Unique per question, no conflicts across files
  - Generated using `vim.loop.hrtime() / 1000000`

Supported comment styles (40+ languages):
  - Block comments: /* */, /** */, --[[ ]], {- -}, (* *)
  - Line comments: //, #, --, ;, %, etc.

==============================================================================
7. VISUAL SELECTION                                          *editutor-visual*

Select code and ask focused questions about it.

Usage:
  1. Enter visual mode (v or V)
  2. Select the code block you want to ask about
  3. Press <leader>mq

A question block is created with your selection quoted: >
    /* [Q:q_1737200000000]
    Regarding this code:
    ```
    function processData(items) {
      return items.filter(x => x.active).map(x => x.value);
    }
    ```

    [PENDING:q_1737200000000]
    */
<

Type your question after the code block, then press <leader>ma.

==============================================================================
8. BATCH PROCESSING                                          *editutor-batch*

Multiple pending questions are processed in one LLM request.

Example - two pending questions: >
    /* [Q:q_1737200000000]
    What is closure?
    [PENDING:q_1737200000000]
    */

    function example() {
      // ...code...
    }

    /* [Q:q_1737200001000]
    How does async work?
    [PENDING:q_1737200001000]
    */
<

Press <leader>ma once - both questions are answered in a single request.

Benefits:
  - Efficient API usage
  - Context is shared across questions
  - Faster than processing one by one

==============================================================================
9. CONTEXT EXTRACTION                                       *editutor-context*

ai-editutor automatically gathers context from your project:

Small projects (<20K tokens):
  - Sends entire codebase (FULL_PROJECT mode)
  - Project tree structure included

Large projects (>20K tokens):
  - ADAPTIVE mode:
    - Current file (full)
    - Import graph (files you import + files that import you)
    - LSP definitions (deduplicated)
    - Project structure tree

Token budget is configurable via `context.token_budget`.

==============================================================================
10. KNOWLEDGE TRACKING                                     *editutor-knowledge*

All Q&A pairs are automatically saved for future reference.

Storage Structure: >
    ~/.local/share/nvim/editutor/knowledge/
    ├── 2026-01-15.json
    ├── 2026-01-16.json
    ├── 2026-01-17.json
    └── ...
<
Each day gets its own file. Easy to manage, review, or delete.

Commands:
  :EditutorHistory        Show recent Q&A (last 20 entries)
  :EditutorBrowse         List available dates
  :EditutorBrowse [date]  Show entries for specific date
  :EditutorExport [path]  Export to markdown

==============================================================================
11. COMMANDS                                                *editutor-commands*

Core Commands:
  :EditutorQuestion       Spawn a new question block
  :EditutorAsk            Process all pending questions in current file
  :EditutorPending        Show pending question count

Knowledge Commands:
  :EditutorHistory        Show recent Q&A history
  :EditutorBrowse [date]  Browse by date (tab-complete dates)
  :EditutorExport [path]  Export to markdown

Language Commands:
  :EditutorLang           Show/set language
  :EditutorLang English   English responses
  :EditutorLang Vietnamese Vietnamese responses

Other Commands:
  :EditutorClearCache     Clear context cache
  :EditutorLog            Open debug log
  :EditutorClearLog       Clear debug log
  :checkhealth editutor   Check plugin health

==============================================================================
12. KEYMAPS                                                  *editutor-keymaps*

Default keymaps (configurable):

  Normal mode:
    <leader>mq    Spawn question block at cursor
    <leader>ma    Process all pending questions

  Visual mode:
    <leader>mq    Spawn question block with selected code

==============================================================================
13. API                                                          *editutor-api*

Main API: >lua
    local editutor = require("editutor")

    editutor.setup(opts)
    editutor.spawn_question()         -- Spawn question block (normal mode)
    editutor.spawn_question_visual()  -- Spawn with visual selection
    editutor.ask()                    -- Process all pending questions
    editutor.show_pending()           -- Show pending count
    editutor.version()                -- Returns version string ("3.0.0")
<

Parser API: >lua
    local parser = require("editutor.parser")

    parser.generate_id()                       -- Generate unique question ID
    parser.find_pending_questions(bufnr)       -- Find all [PENDING:id] blocks
    parser.find_question_by_id(id, bufnr)      -- Find specific question
    parser.count_pending_questions(bufnr)      -- Count pending questions
    parser.has_pending_questions(bufnr)        -- Check if any pending
    parser.get_comment_style(bufnr)            -- Get comment style for buffer
<

Comment Writer API: >lua
    local comment_writer = require("editutor.comment_writer")

    comment_writer.spawn_question_block(bufnr, selected_code)
    comment_writer.replace_pending_with_response(id, response, bufnr)
    comment_writer.replace_pending_batch(responses, bufnr)
<

Provider API: >lua
    local provider = require("editutor.provider")

    provider.query_async(system, user, callback)
    provider.check_provider()                  -- Check if provider is ready
    provider.get_info()                        -- Get provider name and model
    provider.list_providers()                  -- List available providers
<

==============================================================================
vim:tw=78:ts=8:ft=help:norl:
